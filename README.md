# Бинарные деревья поиска
1. [BinaryTreeUnique](#binarytreeunique)** - защищенное дерево без nil-узлов, без узлов с одинаковыми значениями, без возможности удаления отдельных узлов
2. [Node](#node)** - незащищенное дерево с nil-узлами, хранящее каждое значение в отдельном узле, позволяющее удалять отдельные узлы


# BinaryTreeUnique
*binary_tree_unique.rb*
* [Геттеры](#btu-геттеры)
* [Инстансные методы](#btu-инстансные-методы)
* [Описание](#btu-описание)

## BTU: Геттеры
* **numbers_stored** - возвращает общее количество чисел, сохранённых в дереве
* **sum** - возвращает сумму всех чисел
* **min_number** - возвращает минимальное значение дерева
* **max_number** - возвращает максимальное значение дерева

## BTU: Инстансные методы
* **store_number(n)** - добавляет в дерево новое значение
* **store_array(n)** - добавляет в дерево массив
* **show_in_order** - делает симметричный обход дерева, возвращая отсортированный массив исходных данных
* **clear** - очищает дерево, приводя его к исходному состоянию
* **copy** - возвращает дубликат дерева
* **contains?(n)** - определяет, содержит ли дерево значение n

## BTU: Описание
*Эта конкретная модель дерева была нужна для хранения данных в задаче, по условию которой нужно для каждого элемента числового ряда определить, сколько имеется справа чисел, меньших, чем данное*

Данный вариант дерева не создаёт nil-узлов, благодаря чему при его построении не создаётся множество пустых объектов
Оно предназначено только для хранения данных, но не для их редактирования

Обёртка BinaryTree защищает узлы, делая их и их состояния полностью недоступными для изменения пользователями
В связи с этим, каждый метод дерева тоже имеет свою обертку, так как сначала мы вынуждены обращаться к BinaryTree, который уже вызывает рекурсивный метод для корневого узла

Обертка и отличающееся от остальных элементов поведение корня делают слишком сложной реализацию удаления отдельных узлов, поэтому данная функция здесь отсутствует

В узлах дерево хранит только уникальные числа, записывая повторения в счётчик внутри узла - это позволяет исключить ассиметрию веток в случае повторений чисел, но не позволяет вернуть исходный порядок данных

# Node
*binary_tree_simple.rb*
* [Геттер](#node-геттер)
* [Инстансные методы](#node-инстансные-методы)
* [Описание](#node-описание)

## Node: Геттер
* **tree_size** - возвращает размер дерева

## Node: Инстансные методы
* **store_number(n)** - добавляет в дерево новое значение
* **store_array(n)** - добавляет в дерево массив
* **show_in_order** - делает симметричный обход дерева, возвращая отсортированный массив исходных данных
* **clear** - очищает дерево, приводя его к исходному состоянию
* **copy** - возвращает дубликат дерева
* **contains?(n)** - определяет, содержит ли дерево значение n
* **remove_node(n)** - удаляет заданный узел

## Node: Описание
Это простая модель дерева, узлы которого ссылаются на 2 пустых узла, если не имеют ссылок на иные узлы

Также дерево является незащищенным, так как пользователь имеет доступ к любому из узлов

Каждое число сохраняется в отдельном узле. Числа, равные значению узла, сохраняются в левом поддереве
